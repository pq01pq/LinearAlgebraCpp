#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>

namespace linalg {

	class ExceptionHandler;
	class ExceptionArgument;
	class LengthArgument;
	class RowIndexArgument;
	class ColumnIndexArgument;
	class OperationArgument;
	class EtcArgument;
	enum class ExceptionState;
	enum class LengthState;
	enum class IndexState;
	enum class OperationState;
	enum class EtcState;

	/*
	* ExceptionHandler class is made to standardize exception handling for object oriented programming.
	* It throws exception object derived from std::logic_error(use try-catch clause with std::logic_error)
	* 
	* Exception handling order :
	* 1. Check state and generate exception number
	* 2. Check exception number to check if exception occurs
	* 3. When excepion occurs, set exception argument and exception number into exception handler object
	* 4. throws exception with exception argument :
	*    which is generated by derived exception argument class through method override.
	*/
	class ExceptionHandler {
	public:
		ExceptionHandler(const ExceptionState exceptionState, const int exceptionNumber);
		~ExceptionHandler();

		void setExceptionState(const ExceptionState exceptionState);
		void setExceptionNumber(const int exceptionNumber);
		void addArgument(ExceptionArgument& exceptionArg); // (recommended) Add argument in printing order
		void handleException(); // throw exception derived from std::logic_error

		static const int checkValidHeight(const int height); // Check valid height on height allocation
		static const int checkValidWidth(const int width); // Check valid width on width allocation

		static const int checkRowIndex(const int row, const int height); // Check row index on row reference
		static const int checkColumnIndex(const int col, const int width); // Check column index on column reference

		static const int checkHeight(const int height1, const int height2); // Check equal height on operation
		static const int checkWidth(const int width1, const int width2); // Check equal width on operation
		static const int checkJoinLength(const int width, const int height); // Check length equal on dot product
	private:
		ExceptionState exceptionState;
		int exceptionNumber;
		std::vector<ExceptionArgument*> exceptionArgs;
		// Pointer template prevents object slicing and preserve derived class on promotion(up-casting)

		// Generate exception string( e.what() ) by exception arguments
		const std::string getLengthErrorString() const;
		const std::string getOutOfRangeString() const;
		const std::string getArithmeticExceptionString() const;
		const std::string getEtcExceptionString() const;
	};




	/*
	* Exception arguments save informations of state of exception
	* to generate customized exception string by following exception state.
	*/

	// Base class of all exception arguments
	class ExceptionArgument {
		friend class ExceptionHandler;
	public:
		// Overriding str() method allows using derived class' str() method without forced down-casting
		inline virtual const std::string str() const { return "NaN"; };
		
	};
	/*
	* "다운캐스팅이 있다는 것은 디자인이 잘못된 것을 의미하기 때문에
	*  전문 C++ 프로그래머는 다운캐스팅을 부정적으로 본다."
	*  - [Marc Gregoire] Professional C++ (전문가를 위한 C++) 10.3.4 -
	*/

	// Length allocation exception argument
	class LengthArgument : public ExceptionArgument {
		friend class ExceptionHandler;
		friend class IndexArgument;
		friend class OperationArgument;
	public:
		LengthArgument(const int height, const int width);
		~LengthArgument();

		virtual const std::string str() const override;
	private:
		int height, width;
	};

	// Index reference out of range exception argument
	class RowIndexArgument : public ExceptionArgument {
		friend class ExceptionHandler;
	public:
		RowIndexArgument(const int row, const int height);
		~RowIndexArgument();

		virtual const std::string str() const override;
	private:
		int row, height;
	};
	class ColumnIndexArgument : public ExceptionArgument {
		friend class ExceptionHandler;
	public:
		ColumnIndexArgument(const int col, const int width);
		~ColumnIndexArgument();

		virtual const std::string str() const override;
	private:
		int col, width;
	};

	// Arithmetic exception argument
	class OperationArgument : public ExceptionArgument {
		friend class ExceptionHandler;
	public:
		OperationArgument(const char operation, const LengthArgument& lengthArg1, const LengthArgument& lengthArg2);
		~OperationArgument();

		virtual const std::string str() const override;
	private:
		char operation;
		LengthArgument lengthArg1, lengthArg2;
	};

	// All other exception argument
	class EtcArgument : public ExceptionArgument {
		friend class ExceptionHandler;
	public:
		EtcArgument(const std::string& what);
		~EtcArgument();

		virtual const std::string str() const override;
	private:
		std::string what;
	};





	// Type of exception state
	enum class ExceptionState {
		NoExcept,
		LengthError,
		OutOfRange,
		ArithmeticException,
		EtcException
	};

	/*
	* Exception Numbers use binary number system
	* and add each numbers when checking multiple similar type exceptions
	* to guarantee unique combination of exceptions.
	* Each bit represents NoExcept : 0, Exception : 1
	*/
	// Length allocation exception number
	enum class LengthState {
		NoExcept = 0,
		InvalidHeight = 1,
		InvalidWidth = 2,
		InvalidHeightAndWidth = 3 // == (int)InvalidHeight + (int)InvalidWidth
	};
	// Index reference out of range exception number
	enum class IndexState {
		NoExcept = 0,
		RowIndexOutOfRange = 1,
		ColumnIndexOutOfRange = 2,
		BothIndexOutOfRange = 3 // == (int)RowIndexOutOfRange + (int)ColumnIndexOutOfRange
	};
	// Arithmetic exception number
	enum class OperationState {
		NoExcept = 0,
		HeightDoNotMatch = 1,
		WidthDoNotMatch = 2,
		BothLengthDoNotMatch = 3, // == (int)HeightDoNotMatch + (int)WidthDoNotMatch
		JoinLengthDoNotMatch = 4,
		DivideByZero = 8
	};
	// All other exception number
	enum class EtcState {
		NoExcept = 0,
		Exception = 1
	};
}